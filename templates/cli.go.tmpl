// Code generated by cligen. DO NOT EDIT.
package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/spf13/pflag"
)

var _ = strings.TrimSpace // Avoid unused import error

// {{title .Command}}Command represents the {{.Command}} command
type {{title .Command}}Command struct {
	{{range .Fields}}{{.Name}} {{.Type}}
	{{end}}
}

// {{title .Command}}Handler defines the interface for implementing the {{.Command}} command
type {{title .Command}}Handler interface {
	{{title .Command}}Command(args *{{title .Command}}Command) error
}

// Execute runs the {{.Command}} command
func (c *{{title .Command}}Command) Execute() error {
	// Try to find an implementation of the command
	if handler, ok := interface{}(c).({{title .Command}}Handler); ok {
		return handler.{{title .Command}}Command(c)
	}
	
	// No implementation found - show helpful message
	fmt.Fprintf(os.Stderr, "Command '{{.Command}}' is not implemented.\n")
	fmt.Fprintf(os.Stderr, "To implement this command, add the following method to your code:\n\n")
	fmt.Fprintf(os.Stderr, "func (c *{{title .Command}}Command) {{title .Command}}Command(args *{{title .Command}}Command) error {\n")
	fmt.Fprintf(os.Stderr, "    // Your implementation here\n")
	fmt.Fprintf(os.Stderr, "    // Access arguments via args.Port, args.Env, etc.\n")
	fmt.Fprintf(os.Stderr, "    return nil\n")
	fmt.Fprintf(os.Stderr, "}\n\n")
	fmt.Fprintf(os.Stderr, "Command arguments: %+v\n", c)
	return fmt.Errorf("command not implemented")
}

// New{{title .Command}}Command creates and configures the {{.Command}} command
func New{{title .Command}}Command() *{{title .Command}}Command {
	cmd := &{{title .Command}}Command{}
	
	// Define flags
	{{range .Fields}}{{$help := ""}}{{if .Usage}}{{$help = .Usage}}{{else}}{{$help = .CLIName}}{{end}}{{if .Required}}{{$help = printf "%s (required)" $help}}{{end}}{{if .Options}}{{$help = printf "%s [%s]" $help (join .Options "|")}}{{end}}{{if eq .Type "string"}}pflag.StringVarP(&cmd.{{.Name}}, "{{.CLIName}}", "{{.ShortFlag}}", "{{.DefaultValue}}", "{{$help}}")
	{{else if eq .Type "int"}}pflag.IntVarP(&cmd.{{.Name}}, "{{.CLIName}}", "{{.ShortFlag}}", {{if .DefaultValue}}{{.DefaultValue}}{{else}}0{{end}}, "{{$help}}")
	{{else if eq .Type "bool"}}pflag.BoolVarP(&cmd.{{.Name}}, "{{.CLIName}}", "{{.ShortFlag}}", {{if .DefaultValue}}{{.DefaultValue}}{{else}}false{{end}}, "{{$help}}")
	{{else if eq .Type "[]string"}}pflag.StringSliceVarP(&cmd.{{.Name}}, "{{.CLIName}}", "{{.ShortFlag}}", {{if .DefaultValue}}[]string{{"{{.DefaultValue}}"}}{{else}}nil{{end}}, "{{$help}}")
	{{end}}{{end}}
	
	return cmd
}

// Parse parses the command line flags and validates them
func (c *{{title .Command}}Command) Parse() error {
	// Parse flags
	pflag.Parse()
	
	// Validate required fields
	{{range .Fields}}{{if .Required}}if c.{{.Name}} == {{if eq .Type "string"}}"" {{else if eq .Type "int"}}0 {{else if eq .Type "bool"}}false {{else}}nil {{end}}{
		fmt.Fprintf(os.Stderr, "Error: --%s is required\n", "{{.CLIName}}")
		pflag.Usage()
		os.Exit(1)
	}
	{{end}}{{end}}
	
	// Validate options
	{{range .Fields}}{{if .Options}}if c.{{.Name}} != "" {
		validOptions := []string{ {{range .Options}}"{{.}}", {{end}} }
		valid := false
		for _, opt := range validOptions {
			if c.{{.Name}} == opt {
				valid = true
				break
			}
		}
		if !valid {
			fmt.Fprintf(os.Stderr, "Error: --%s must be one of: %s\n", "{{.CLIName}}", strings.Join(validOptions, ", "))
			pflag.Usage()
			os.Exit(1)
		}
	}
	{{end}}{{end}}
	
	return nil
}

func main() {
	cmd := New{{title .Command}}Command()
	
	// Set up custom usage function
	pflag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [options]\n", "{{.Command}}")
		fmt.Fprintf(os.Stderr, "\n{{.Help}}\n\n")
		fmt.Fprintf(os.Stderr, "Options:\n")
		pflag.PrintDefaults()
	}

	// Check for help flags
	if len(os.Args) > 1 && (os.Args[1] == "--help" || os.Args[1] == "-h") {
		pflag.Usage()
		return
	}
	
	// Parse and validate flags
	if err := cmd.Parse(); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing flags: %v\n", err)
		os.Exit(1)
	}
	
	if err := cmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
} 